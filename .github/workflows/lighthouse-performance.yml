name: Lighthouse Performance

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: lighthouse-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lighthouse:
    name: Lighthouse Performance Audit
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build
        env:
          CI: true

      - name: Install Lighthouse CI
        run: npm install -g @lhci/cli@0.13.x

      - name: Serve build
        run: |
          npx serve -s dist -l 8080 &
          echo $! > .servepid

      - name: Wait for server
        run: npx wait-on http://localhost:8080 --timeout 60000

      - name: Run Lighthouse CI
        run: lhci autorun --config=.lighthouserc.json
        continue-on-error: true

      - name: Stop server
        if: always()
        run: |
          if [ -f .servepid ]; then
            kill $(cat .servepid) || true
            rm .servepid
          fi

      - name: Upload Lighthouse reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-reports
          path: |
            .lighthouseci/
            lighthouse-reports/
          retention-days: 30

      - name: Process Lighthouse results
        id: lighthouse-results
        run: |
          # Create reports directory
          mkdir -p lighthouse-reports
          
          # Process results
          node scripts/process-lighthouse-results.js
          
          # Read processed results
          if [ -f lighthouse-reports/summary.json ]; then
            echo "results_available=true" >> $GITHUB_OUTPUT
          else
            echo "results_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Download baseline results (if PR)
        if: github.event_name == 'pull_request'
        continue-on-error: true
        run: |
          # Try to download baseline from main branch artifacts
          gh run download --repo ${{ github.repository }} --branch main --name lighthouse-reports --dir baseline-reports || true
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Compare with baseline
        if: github.event_name == 'pull_request' && steps.lighthouse-results.outputs.results_available == 'true'
        id: comparison
        run: |
          node scripts/compare-lighthouse-results.js

      - name: Generate performance report
        if: always()
        run: |
          node scripts/generate-performance-report.js

      - name: Comment PR with results
        if: github.event_name == 'pull_request' && steps.lighthouse-results.outputs.results_available == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Read summary
            let summary = {};
            try {
              summary = JSON.parse(fs.readFileSync('lighthouse-reports/summary.json', 'utf8'));
            } catch (error) {
              console.log('Could not read summary:', error);
              return;
            }
            
            // Read comparison if available
            let comparison = null;
            try {
              comparison = JSON.parse(fs.readFileSync('lighthouse-reports/comparison.json', 'utf8'));
            } catch (error) {
              console.log('No comparison available');
            }
            
            const testUrl = `https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            
            // Helper functions
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'üü¢';
              if (score >= 50) return 'üü°';
              return 'üî¥';
            };
            
            const getScoreBar = (score) => {
              const filled = Math.round(score / 10);
              const empty = 10 - filled;
              return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
            };
            
            const formatMs = (ms) => {
              if (ms >= 1000) return `${(ms / 1000).toFixed(2)}s`;
              return `${Math.round(ms)}ms`;
            };
            
            const getDelta = (current, baseline) => {
              if (!baseline) return '';
              const diff = current - baseline;
              if (Math.abs(diff) < 1) return '';
              const sign = diff > 0 ? '+' : '';
              const emoji = diff > 0 ? 'üìâ' : 'üìà';
              return ` ${emoji} ${sign}${diff.toFixed(0)}`;
            };
            
            // Build comment
            let comment = `## üöÄ Lighthouse Performance Report\n\n`;
            comment += `[View Full Report](${testUrl})\n\n`;
            
            // Performance scores
            comment += `### üìä Performance Scores\n\n`;
            comment += `| Category | Score | Visual | Status |\n`;
            comment += `|----------|-------|--------|--------|\n`;
            
            const categories = ['performance', 'accessibility', 'best-practices', 'seo', 'pwa'];
            const categoryNames = {
              'performance': 'Performance',
              'accessibility': 'Accessibility',
              'best-practices': 'Best Practices',
              'seo': 'SEO',
              'pwa': 'PWA'
            };
            
            for (const cat of categories) {
              const score = summary.scores?.[cat] || 0;
              const baseline = comparison?.baseline?.scores?.[cat];
              const emoji = getScoreEmoji(score);
              const bar = getScoreBar(score);
              const delta = baseline ? getDelta(score, baseline) : '';
              const status = score >= 90 ? 'Pass' : score >= 50 ? 'Warn' : 'Fail';
              comment += `| ${emoji} ${categoryNames[cat]} | ${score} | \`${bar}\` ${delta} | ${status} |\n`;
            }
            
            comment += `\n`;
            
            // Core Web Vitals
            if (summary.metrics) {
              comment += `### üéØ Core Web Vitals\n\n`;
              comment += `| Metric | Value | Threshold | Status |\n`;
              comment += `|--------|-------|-----------|--------|\n`;
              
              const vitals = [
                { key: 'lcp', name: 'Largest Contentful Paint', threshold: 2500, unit: 'ms', good: 2500 },
                { key: 'fid', name: 'First Input Delay', threshold: 100, unit: 'ms', good: 100 },
                { key: 'cls', name: 'Cumulative Layout Shift', threshold: 0.1, unit: '', good: 0.1 },
                { key: 'fcp', name: 'First Contentful Paint', threshold: 1800, unit: 'ms', good: 1800 },
                { key: 'tti', name: 'Time to Interactive', threshold: 3800, unit: 'ms', good: 3800 },
                { key: 'si', name: 'Speed Index', threshold: 3400, unit: 'ms', good: 3400 },
                { key: 'tbt', name: 'Total Blocking Time', threshold: 200, unit: 'ms', good: 200 },
              ];
              
              for (const vital of vitals) {
                const value = summary.metrics[vital.key];
                if (value !== undefined) {
                  const baseline = comparison?.baseline?.metrics?.[vital.key];
                  const displayValue = vital.unit ? `${formatMs(value)}` : value.toFixed(3);
                  const status = value <= vital.good ? '‚úÖ Good' : value <= vital.threshold * 1.5 ? '‚ö†Ô∏è Needs Improvement' : '‚ùå Poor';
                  const delta = baseline ? ` (${getDelta(value, baseline)})` : '';
                  comment += `| ${vital.name} | **${displayValue}**${delta} | ${vital.threshold}${vital.unit} | ${status} |\n`;
                }
              }
              
              comment += `\n`;
            }
            
            // Performance budget
            if (summary.budgetStatus) {
              const budgetFailed = summary.budgetStatus.failed || 0;
              const budgetTotal = summary.budgetStatus.total || 0;
              
              comment += `### üí∞ Performance Budget\n\n`;
              if (budgetFailed === 0) {
                comment += `‚úÖ **All ${budgetTotal} budget checks passed!**\n\n`;
              } else {
                comment += `‚ö†Ô∏è **${budgetFailed} of ${budgetTotal} budget checks failed**\n\n`;
                if (summary.budgetViolations && summary.budgetViolations.length > 0) {
                  comment += `Failed checks:\n`;
                  for (const violation of summary.budgetViolations) {
                    comment += `- ${violation.metric}: ${violation.actual} (limit: ${violation.budget})\n`;
                  }
                  comment += `\n`;
                }
              }
            }
            
            // Opportunities
            if (summary.opportunities && summary.opportunities.length > 0) {
              comment += `### üí° Top Optimization Opportunities\n\n`;
              const topOpportunities = summary.opportunities.slice(0, 5);
              for (const opp of topOpportunities) {
                const savings = formatMs(opp.numericValue || 0);
                comment += `- **${opp.title}**: Save ~${savings}\n`;
              }
              comment += `\n[View all opportunities](${testUrl})\n\n`;
            }
            
            // Comparison summary
            if (comparison && comparison.summary) {
              comment += `### üìà Changes vs Baseline\n\n`;
              const { improved, regressed, unchanged } = comparison.summary;
              comment += `- ‚úÖ Improved: ${improved} metric(s)\n`;
              comment += `- ‚ö†Ô∏è Regressed: ${regressed} metric(s)\n`;
              comment += `- ‚û°Ô∏è Unchanged: ${unchanged} metric(s)\n\n`;
            }
            
            // Recommendations
            const perfScore = summary.scores?.performance || 0;
            if (perfScore < 90) {
              comment += `### üîß Recommendations\n\n`;
              if (perfScore < 50) {
                comment += `‚ö†Ô∏è **Critical**: Performance score is very low. Consider:\n`;
                comment += `- Reducing JavaScript bundle size\n`;
                comment += `- Optimizing images (use WebP, lazy loading)\n`;
                comment += `- Enabling compression and caching\n`;
                comment += `- Minimizing render-blocking resources\n\n`;
              } else {
                comment += `Consider reviewing the optimization opportunities above to improve performance.\n\n`;
              }
            }
            
            comment += `---\n`;
            comment += `*Tested on: Desktop Chrome | [Performance Guide](https://github.com/${{ github.repository }}/blob/main/PERFORMANCE.md)*`;
            
            // Post or update comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Lighthouse Performance Report')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
            
            // Fail if performance is too low
            const perfScore = summary.scores?.performance || 0;
            if (perfScore < 50) {
              core.setFailed(`Performance score ${perfScore} is below threshold (50)`);
            }
